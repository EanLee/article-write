# 技術評估報告：部落格編輯器自動儲存機制

**專案名稱**：部落格文章編輯器 (React)
**評估日期**：2026-02-14
**文件類型**：Technical Design Document (TDD)
**關鍵字**：Auto-save, Dirty Flag, Hashing, Snapshot, Performance

---

## 1. 背景與目標 (Background & Objective)

### 1.1 需求描述

開發一個支援長篇文章（字數可能達上萬字，約 20KB~100KB 資料量）的部落格編輯器。為了防止使用者資料遺失，需要實作「自動儲存 (Auto-save)」功能。

### 1.2 技術挑戰

* **效能平衡**：需在「即時保存」與「瀏覽器效能（CPU/記憶體）」之間取得平衡，避免打字卡頓。
* **準確性**：需精確判斷內容是否真的變更，避免無意義的網路請求（API Calls）。
* **維護性**：在 React 生態系中，需考量 State 管理與 Component Lifecycle 的複雜度。

---

## 2. 方案比較 (Options Analysis)

針對自動儲存的觸發機制，我們評估了以下三種主流方案：

| 方案 | 機制描述 | 優點 | 缺點 | 適用情境 |
| --- | --- | --- | --- | --- |
| **A. Dirty Flag (髒標記)** | 監聽 `onChange` 事件，一旦觸發即設 `isDirty = true`。 | • 極致效能 (O(1))<br>

<br>• 實作最簡單<br>

<br>• 適合 UI 狀態顯示 (如離開警告) | • **誤判率高**：若使用者打字後又刪除回復原狀，仍會被視為「已修改」。<br>

<br>• 無法得知變更幅度。 | 表單驗證、簡單設定頁面 |
| **B. Hash Comparison (雜湊比對)** | 計算內容的 Hash (MD5/SHA)，比對 `Hash(curr) != Hash(prev)`。 | • 節省網路頻寬 (只需傳送 Hash)<br>

<br>• 適合與後端同步檢核 | • **計算成本高**：每次計算需遍歷全文。<br>

<br>• **複雜度增加**：需引入額外 Library 或處理非同步 Crypto API。 | 協同編輯、P2P 同步、超大型檔案 |
| **C. Snapshot / String Compare** | 保留上次存檔的副本，直接比對 `Current === Saved`。 | • **直觀且準確**：100% 確定內容差異。<br>

<br>• **無額外依賴**：不需要 Hash Library。<br>

<br>• V8 引擎對字串比對有優化。 | • 記憶體消耗較高 (需存兩份資料)，但在 100KB 級別下可忽略。 | 單人編輯器、中長篇內容 (本專案) |

---

## 3. 深度評估：為什麼選擇字串比對而非 Hash (MD5)？

針對本專案「上萬字部落格文章」的情境，我們特別針對 **Hash (MD5)** 與 **Snapshot (String Compare)** 進行了深入分析：

### 3.1 MD5/Hash 的疑慮

雖然 MD5 計算快速且對此場景安全性足夠（僅做指紋比對，非密碼加密），但存在以下劣勢：

1. **套件依賴**：瀏覽器原生不支援同步的 MD5，需引入 `js-md5` 等外部套件，增加 Bundle Size。
2. **效能成本**：Hash 運算本質上仍需讀取每一個字元進行數學運算。
3. **非同步複雜性**：若使用原生 `crypto.subtle` (SHA-256)，則需處理 Promise，增加 React `useEffect` 的邏輯負擔。

### 3.2 String Compare (`===`) 的優勢

在 JavaScript (V8 Engine) 中，字串比對具有極高的優化：

1. **長度優先檢查**：若新舊文章長度不同，耗時趨近於 0。
2. **記憶體位址檢查**：若 Reference 相同，耗時為 0。
3. **短路邏輯**：逐字比對時，一旦發現第一個不同字元即停止。

**結論**：對於 5 萬字以內的文章，直接字串比對的效能消耗極低，且開發維護成本遠低於引入 Hash 機制。

---

## 4. 最終建議方案 (Recommendation)

我們採用 **「混合式三層過濾策略 (Hybrid Approach)」**。此策略結合了 Dirty Flag 的高效能與 Snapshot 的準確性。

### 4.1 架構邏輯

1. **第一層 (UI 層) - Dirty Flag**：
* 利用 React `state` 或 `ref` 記錄 `isDirty`。
* `onChange` 事件觸發時，直接設 `isDirty = true`。
* 此層級負責 UI 反饋（如啟用「儲存按鈕」、頁面跳轉警告）。


2. **第二層 (排程層) - Throttle/Timer**：
* 使用 `setInterval` (例如每 30 秒) 或 `useDebounce` 進行檢查。
* 若 `isDirty === false`，直接跳過，**完全不執行後續比對**，節省 CPU。


3. **第三層 (資料層) - String Compare**：
* 當計時器觸發且 `isDirty === true` 時，執行 `CurrentContent === LastSavedContent`。
* **若相同** (False Positive)：使用者改了又改回來。默默將 `isDirty` 重置為 `false`，**不發送 API**。
* **若不同** (True Positive)：發送 API 儲存資料，成功後更新 `LastSavedContent` 並重置 `isDirty`。



---

## 5. 實作建議 (React Implementation Guide)

### 5.1 關鍵 Hooks 使用

* **`useRef`**：用來儲存 `lastSavedContent` 和 `timerId`。使用 `Ref` 而非 `State` 可以避免比對過程中觸發不必要的 Re-render。
* **`useEffect`**：用來設定 `setInterval` 定期檢查自動儲存邏輯。

### 5.2 虛擬碼 (Pseudo Code)

```javascript
// 狀態定義
const [content, setContent] = useState("");
const isDirty = useRef(false);
const lastSavedContent = useRef("");

// 1. 輸入處理 (第一層過濾)
const handleChange = (newContent) => {
  setContent(newContent);
  isDirty.current = true;
};

// 2. 自動儲存邏輯 (第二、三層過濾)
useEffect(() => {
  const timer = setInterval(() => {
    // 檢查是否標記為髒 (Check Dirty Flag)
    if (!isDirty.current) return;

    // 檢查內容是否真的變更 (String Compare)
    if (content === lastSavedContent.current) {
      console.log("內容未變更，重置 Dirty Flag");
      isDirty.current = false;
      return;
    }

    // 執行儲存
    saveToBackend(content).then(() => {
      lastSavedContent.current = content; // 更新快照
      isDirty.current = false; // 重置標記
      console.log("自動儲存成功");
    });

  }, 30000); // 每 30 秒檢查一次

  return () => clearInterval(timer);
}, [content]); // 依賴 content 以確保讀取最新值

```

---

## 6. 風險與注意事項 (Risks & Notes)

1. **大數據量邊界情況**：若未來文章長度增長至「書籍」等級（例如 > 500KB 純文字），字串比對可能會造成 Main Thread 短暫阻塞（約 10-50ms）。屆時可考慮改用 `requestIdleCallback` 或 Web Worker 進行比對。
2. **Rich Text 格式**：若編輯器輸出的不是純字串而是複雜 JSON (如 Slate.js/Draft.js)，建議在 `onChange` 時先轉換並儲存為字串形式的快照，避免深度物件比對 (Deep Compare) 造成的效能地獄。

---

**文件結束**
